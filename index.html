<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700;900&display=swap" rel="stylesheet">

    <title>Ù…Ø­Ù„Ù„ Ù…ÙˆØ¬Ø§Øª Elliott Wave</title>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: 'Tajawal', sans-serif;
        background: linear-gradient(135deg, #1e1e2f, #0f0f1a);
        color: #f1f1f1;
         font-size: 16px;
         font-weight: 500;
         text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
         direction: rtl;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    .header {
        text-align: center;
        color: #ffffff;
        margin-bottom: 30px;
    }

    .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 6px rgba(0,0,0,0.5);
    }

    .controls, .results {
        background: #2b2b3c;
        border-radius: 15px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    }

    .control-group {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }

    .control-item {
        flex: 1;
        min-width: 200px;
    }

    .control-item label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        color: #ccc;
    }

    .control-item select,
    .control-item input {
        width: 100%;
        padding: 12px;
        border: 2px solid #444;
        background: #1e1e2f;
        color: #f1f1f1;
        border-radius: 8px;
        font-size: 16px;
        transition: border-color 0.3s, background 0.3s;
    }

    .control-item select:focus,
    .control-item input:focus {
        outline: none;
        border-color: #764ba2;
        background: #2e2e4a;
    }

    .button-group {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 20px;
        flex-wrap: wrap;
    }

    button {
        padding: 12px 30px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
        min-width: 150px;
    }

    .btn-primary {
        background: linear-gradient(45deg, #764ba2, #667eea);
        color: white;
    }

    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .btn-secondary {
        background: #3b3b4f;
        color: #ccc;
        border: 2px solid #555;
    }

    .btn-secondary:hover {
        background: #4b4b5f;
    }

    .loading {
        text-align: center;
        padding: 40px;
        color: #aaa;
    }

    .spinner {
        border: 4px solid #444;
        border-top: 4px solid #764ba2;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .analysis-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #444;
    }

    .symbol-info h2 {
        color: #eee;
        margin-bottom: 5px;
    }

    .symbol-info .price {
        font-size: 1.5rem;
        font-weight: bold;
        color: #4caf50;
    }

    .status-badge {
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        text-transform: uppercase;
        font-size: 12px;
    }

    .status-success {
        background: #2e7d32;
        color: #c8fdd9;
    }

    .status-error {
        background: #c62828;
        color: #ffdada;
    }

    .patterns-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
    }

    .pattern-card {
        background: #323246;
        border-radius: 10px;
        padding: 20px;
        border-left: 5px solid #764ba2;
    }

    .pattern-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .pattern-type {
        font-weight: bold;
        color: #f1f1f1;
        font-size: 1.1rem;
    }

    .confidence {
        background: #667eea;
        color: white;
        padding: 4px 12px;
        border-radius: 15px;
        font-size: 14px;
        font-weight: bold;
    }

    .confidence.high {
        background: #28a745;
    }

    .confidence.medium {
        background: #ffc107;
        color: #222;
    }

    .confidence.low {
        background: #dc3545;
    }

    .pattern-direction {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
    }

    .direction-arrow {
        font-size: 1.5rem;
    }

    .direction-up {
        color: #28a745;
    }

    .direction-down {
        color: #dc3545;
    }

    .summary-box {
        background: #1a1a2b;
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
        border-right: 5px solid #007bff;
        color: #ccc;
    }

    .error-message {
        background: #512d2d;
        color: #ffb3b3;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #a94442;
        margin-top: 20px;
    }

    @media (max-width: 768px) {
        .container {
            padding: 10px;
        }

        .header h1 {
            font-size: 2rem;
        }

        .control-group {
            flex-direction: column;
        }

        .button-group {
            flex-direction: column;
        }

        button {
            min-width: auto;
        }
    }
</style>

   <script src="webAPI-direct.js"></script>
    <script src="elliottWaveAnalyzer.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒŠ Ù…Ø­Ù„Ù„ Ù…ÙˆØ¬Ø§Øª Elliott Wave</h1>
            <p>ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ø£Ø³ÙˆØ§Ù‚ Ø§Ù„Ù…Ø§Ù„ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø¸Ø±ÙŠØ© Elliott Wave</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="control-item">
                    <label for="symbolSelect">Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ù…Ø§Ù„ÙŠ:</label>
                    <select id="symbolSelect">
                        <option value="BTCUSDT">Bitcoin (BTC/USDT)</option>
                        <option value="ETHUSDT">Ethereum (ETH/USDT)</option>
                        <option value="ADAUSDT">Cardano (ADA/USDT)</option>
                        <option value="BNBUSDT">Binance Coin (BNB/USDT)</option>
                        <option value="XRPUSDT">Ripple (XRP/USDT)</option>
                        <option value="SOLUSDT">Solana (SOL/USDT)</option>
                        <option value="DOTUSDT">Polkadot (DOT/USDT)</option>
                        <option value="LINKUSDT">Chainlink (LINK/USDT)</option>
                    </select>
                </div>
                
                <div class="control-item">
                    <label for="intervalSelect">Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©:</label>
                    <select id="intervalSelect">
                        <option value="15m">15 Ø¯Ù‚ÙŠÙ‚Ø©</option>
                        <option value="30m">30 Ø¯Ù‚ÙŠÙ‚Ø©</option>
                        <option value="1h" selected>Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©</option>
                        <option value="4h">4 Ø³Ø§Ø¹Ø§Øª</option>
                        <option value="1d">ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯</option>
                        <option value="1w">Ø£Ø³Ø¨ÙˆØ¹ ÙˆØ§Ø­Ø¯</option>
                    </select>
                </div>
                
                <div class="control-item">
                    <label for="limitInput">Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹:</label>
                    <input type="number" id="limitInput" value="100" min="50" max="500">
                </div>
            </div>

            <div class="button-group">
                <button class="btn-primary" onclick="analyzeSymbol()">
                    ğŸ” ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø²
                </button>
                <button class="btn-secondary" onclick="startContinuousAnalysis()">
                    ğŸ”„ ØªØ­Ù„ÙŠÙ„ Ù…Ø³ØªÙ…Ø±
                </button>
                <button class="btn-secondary" onclick="stopContinuousAnalysis()">
                    â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ù„ÙŠÙ„
                </button>
                <button class="btn-secondary" onclick="clearResults()">
                    ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
                </button>
            </div>
        </div>

        <div id="results" class="results" style="display: none;">
            <!-- Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ -->
        </div>
    </div>

    <script>
        let continuousAnalysisInterval = null;
        let isAnalyzing = false;
        
        // Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„Ù…Ø«Ù„Ù‰ Ø­Ø³Ø¨ Ø§Ù„ÙØ±ÙŠÙ… (ØªØ­Ù„ÙŠÙ„ 24 Ø³Ø§Ø¹Ø©)
       function getOptimalCandleCount(interval) {
    const candleCounts = {
        '15m': 200, 
        '30m': 300,  
        '1h': 400,   
        '4h': 200,    
        '1d': 100,    
        '1w': 20      
    };
    return candleCounts[interval] || 300; // Ø±Ù‚Ù… Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ùˆ Ø§Ù„Ø¥Ø·Ø§Ø± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯
}

        
        // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„ÙØ±ÙŠÙ…
        document.getElementById('intervalSelect').addEventListener('change', function() {
            const selectedInterval = this.value;
            const optimalCount = getOptimalCandleCount(selectedInterval);
            document.getElementById('limitInput').value = optimalCount;
        });

        // Ø¯Ø§Ù„Ø© ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø²
        async function analyzeSymbol() {
            if (isAnalyzing) {
                showError('Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¨Ø§Ù„ÙØ¹Ù„...');
                return;
            }

            const symbol = document.getElementById('symbolSelect').value;
            const interval = document.getElementById('intervalSelect').value;
            const limit = getOptimalCandleCount(interval);

            showLoading('Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ ' + symbol + '...');
            isAnalyzing = true;

            try {
                // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ API
                const analysis = await simulateAnalysis(symbol, interval, limit);
                displayResults(analysis);
            } catch (error) {
                showError('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„: ' + error.message);
            } finally {
                isAnalyzing = false;
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ…Ø±
        function startContinuousAnalysis() {
            if (continuousAnalysisInterval) {
                showError('Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙŠØ¹Ù…Ù„ Ø¨Ø§Ù„ÙØ¹Ù„');
                return;
            }

            analyzeSymbol();
            continuousAnalysisInterval = setInterval(() => {
                if (!isAnalyzing) {
                    analyzeSymbol();
                }
            }, 60000); // ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø©

            showInfo('ØªÙ… Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ…Ø± - Ø³ÙŠØªÙ… Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø©');
        }

        // Ø¯Ø§Ù„Ø© Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ…Ø±
        function stopContinuousAnalysis() {
            if (continuousAnalysisInterval) {
                clearInterval(continuousAnalysisInterval);
                continuousAnalysisInterval = null;
                showInfo('ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ…Ø±');
            } else {
                showError('Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ…Ø± ØºÙŠØ± Ù†Ø´Ø·');
            }
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø­ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        function clearResults() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.style.display = 'none';
            resultsDiv.innerHTML = '';
        }

        // Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
        function showLoading(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>${message}</p>
                </div>
            `;
            resultsDiv.style.display = 'block';
        }

        // Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        function displayResults(analysis) {
            const resultsDiv = document.getElementById('results');
            
            if (analysis.status === 'success') {
                resultsDiv.innerHTML = `
                    <div class="analysis-header">
                        <div class="symbol-info">
                            <h2>${analysis.symbol}</h2>
                            <div class="price">$${analysis.currentPrice.toFixed(4)}</div>
                        </div>
                        <div class="status-badge status-success">Ù†Ø¬Ø­ Ø§Ù„ØªØ­Ù„ÙŠÙ„</div>
                    </div>

                    <div class="patterns-grid">
                        ${analysis.patterns.map(pattern => `
                            <div class="pattern-card">
                                <div class="pattern-header">
                                    <div class="pattern-type">${pattern.type}</div>
                                    <div class="confidence ${getConfidenceClass(pattern.confidence)}">
                                        ${pattern.confidence.toFixed(1)}%
                                    </div>
                                </div>
                                <div class="pattern-direction">
                                    <span class="direction-arrow ${pattern.direction === 'ØµØ§Ø¹Ø¯' ? 'direction-up' : 'direction-down'}">
                                        ${pattern.direction === 'ØµØ§Ø¹Ø¯' ? 'ğŸ“ˆ' : 'ğŸ“‰'}
                                    </span>
                                    <span>${pattern.direction}</span>
                                </div>
                                <div class="pattern-details">
                                    <p><strong>ğŸ“ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©:</strong> Ø§Ù„Ø´Ù…Ø¹Ø© Ø±Ù‚Ù… ${pattern.startIndex} (Ù…Ù† ${pattern.totalCandles} Ø´Ù…Ø¹Ø©)</p>
                                    <p><strong>ğŸ Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©:</strong> Ø§Ù„Ø´Ù…Ø¹Ø© Ø±Ù‚Ù… ${pattern.endIndex} (Ù…Ù† ${pattern.totalCandles} Ø´Ù…Ø¹Ø©)</p>
                                    <p><strong>ğŸ“ Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©:</strong> ${pattern.endIndex - pattern.startIndex} Ø´Ù…Ø¹Ø©</p>
                                    <p><strong>ğŸ“Š Ø·ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬Ø©:</strong> ${pattern.waveLength.toFixed(2)}%</p>
                                    <p><strong>ğŸ¯ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:</strong> $${pattern.target}</p>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div class="summary-box">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3>ğŸ“ Ù…Ù„Ø®Øµ Ø§Ù„ØªØ­Ù„ÙŠÙ„</h3>
                            <button class="btn-secondary" onclick="copyAnalysis()" style="min-width: auto; padding: 8px 16px;">
                                ğŸ“‹ Ù†Ø³Ø® Ø§Ù„ØªØ­Ù„ÙŠÙ„
                            </button>
                        </div>
                        <p>${analysis.summary}</p>
                        <p><strong>Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ÙƒØªØ´ÙØ©:</strong> ${analysis.patterns.length}</p>
                        <p><strong>ÙˆÙ‚Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„:</strong> ${new Date().toLocaleString('ar-SA')}</p>
                    </div>
                `;
            } else {
                resultsDiv.innerHTML = `
                    <div class="analysis-header">
                        <div class="symbol-info">
                            <h2>${analysis.symbol || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</h2>
                        </div>
                        <div class="status-badge status-error">ÙØ´Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„</div>
                    </div>
                    <div class="error-message">
                        <h3>âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„</h3>
                        <p>${analysis.message}</p>
                    </div>
                `;
            }
            
            resultsDiv.style.display = 'block';
        }

        // Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ¯ ÙØ¦Ø© Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
        function getConfidenceClass(confidence) {
            if (confidence >= 75) return 'high';
            if (confidence >= 60) return 'medium';
            return 'low';
        }

        // Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
        function showError(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="error-message">
                    <h3>âŒ Ø®Ø·Ø£</h3>
                    <p>${message}</p>
                </div>
            `;
            resultsDiv.style.display = 'block';
        }

        // Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
        function showInfo(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="summary-box">
                    <h3>â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª</h3>
                    <p>${message}</p>
                </div>
            `;
            resultsDiv.style.display = 'block';
        }

        // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… API Ø­Ù‚ÙŠÙ‚ÙŠ
        async function simulateAnalysis(symbol, interval, limit) {
            try {
                // Ø¥Ù†Ø´Ø§Ø¡ instance Ù…Ù† WebBinanceAPI
                const binanceAPI = new WebBinanceAPI();
                
                // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
                const [klineData, currentPrice] = await Promise.all([
                    binanceAPI.getKlineData(symbol, interval, limit),
                    binanceAPI.getCurrentPrice(symbol)
                ]);
                
                // ØªØ­Ù„ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ù…ÙˆØ¹ ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø£Ù†Ù…Ø§Ø·
                const patterns = analyzeKlineData(klineData, currentPrice);
                
                // ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø­Ø³Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
                patterns.sort((a, b) => b.confidence - a.confidence);
                
                return {
                    status: 'success',
                    symbol: symbol,
                    currentPrice: currentPrice,
                    patterns: patterns,
                    summary: patterns.length > 0 ? 
                        `ØªÙ… Ø§ÙƒØªØ´Ø§Ù ${patterns.length} Ù†Ù…Ø·. Ø£Ù‚ÙˆÙ‰ Ø¥Ø´Ø§Ø±Ø© Ù‡ÙŠ ${patterns[0].type} ${patterns[0].direction} Ø¨Ø«Ù‚Ø© ${patterns[0].confidence.toFixed(1)}%` :
                        'Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£Ù†Ù…Ø§Ø· ÙˆØ§Ø¶Ø­Ø© ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ'
                };
                
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', error);
                return {
                    status: 'error',
                    symbol: symbol,
                    message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ùˆ ØªØ­Ù„ÙŠÙ„Ù‡Ø§: ' + error.message
                };
            }
        }
        
        // Ø¯Ø§Ù„Ø© ØªØ­Ù„ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ù…ÙˆØ¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ù„Ù„ Ø§Ù„Ø£ØµÙ„ÙŠ Elliott Wave
        function analyzeKlineData(klineData, realCurrentPrice) {
            if (!klineData || klineData.length < 10) {
                return [];
            }
            
            try {
                // Ø¥Ù†Ø´Ø§Ø¡ instance Ù…Ù† Ø§Ù„Ù…Ø­Ù„Ù„ Ø§Ù„Ø£ØµÙ„ÙŠ
                const analyzer = new ElliottWaveAnalyzer();
                
                // ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ù…ÙˆØ¹ Ù„Ù„ØµÙŠØºØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
                const priceData = klineData.map((candle, index) => ({
                    index: index,
                    timestamp: parseInt(candle[0]),
                    open: parseFloat(candle[1]),
                    high: parseFloat(candle[2]),
                    low: parseFloat(candle[3]),
                    close: parseFloat(candle[4]),
                    volume: parseFloat(candle[5])
                }));
                
                const currentPrice = realCurrentPrice || priceData[priceData.length - 1].close;
                const totalCandles = klineData.length;
                
                // ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£ØµÙ„ÙŠ
                const analysisResults = analyzer.analyzeMarketData(priceData);
                
                // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„Ù„ØµÙŠØºØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
                const patterns = [];
                
                if (analysisResults && analysisResults.patterns) {
                    analysisResults.patterns.forEach(pattern => {
                        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…ÙˆØ¬Ø©
                        let direction = 'ØµØ§Ø¹Ø¯';
                        if (pattern.type && (pattern.type.includes('correction') || 
                            pattern.type.includes('ØªØµØ­ÙŠØ­') || 
                            pattern.points && pattern.points.length >= 2 &&
                            pattern.points[pattern.points.length - 1].price < pattern.points[0].price)) {
                            direction = 'Ù‡Ø§Ø¨Ø·';
                        }
                        
                        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…ØªÙˆÙ‚Ø¹
                        let target = currentPrice;
                        if (pattern.projections && pattern.projections.length > 0) {
                            target = pattern.projections[0].price;
                        } else {
                            // Ø­Ø³Ø§Ø¨ ØªÙ‚Ø±ÙŠØ¨ÙŠ Ù„Ù„Ù‡Ø¯Ù
                            const waveLength = pattern.waveLength || 0.05;
                            target = direction === 'ØµØ§Ø¹Ø¯' ? 
                                (currentPrice * (1 + waveLength)).toFixed(4) :
                                (currentPrice * (1 - waveLength)).toFixed(4);
                        }
                        
                        patterns.push({
                            type: translatePatternType(pattern.type) || 'Ù…ÙˆØ¬Ø© Ø¯Ø§ÙØ¹Ø©',
                            direction: direction,
                            confidence: pattern.confidence || 70,
                            startIndex: pattern.startIndex || 1,
                            endIndex: pattern.endIndex || totalCandles - 1,
                            waveLength: (pattern.waveLength || 0.05) * 100,
                            target: target.toString(),
                            totalCandles: totalCandles
                        });
                    });
                }
                
                // Ø¥Ø°Ø§ Ù„Ù… ÙŠØ¬Ø¯ Ø§Ù„Ù…Ø­Ù„Ù„ Ø£Ù†Ù…Ø§Ø·ØŒ Ø£Ù†Ø´Ø¦ Ù†Ù…Ø· Ø§ØªØ¬Ø§Ù‡ Ø¹Ø§Ù…
                if (patterns.length === 0) {
                    const prices = priceData.map(d => d.close);
                    const firstPrice = prices[0];
                    const lastPrice = prices[prices.length - 1];
                    const trendDirection = lastPrice > firstPrice ? 'ØµØ§Ø¹Ø¯' : 'Ù‡Ø§Ø¨Ø·';
                    const trendStrength = Math.abs(lastPrice - firstPrice) / firstPrice;
                    
                    patterns.push({
                        type: trendDirection === 'ØµØ§Ø¹Ø¯' ? 'Ù…ÙˆØ¬Ø© Ø¯Ø§ÙØ¹Ø©' : 'Ù…ÙˆØ¬Ø© ØªØµØ­ÙŠØ­ÙŠØ©',
                        direction: trendDirection,
                        confidence: Math.min(85, 60 + (trendStrength * 300)),
                        startIndex: 1,
                        endIndex: totalCandles - 1,
                        waveLength: trendStrength * 100,
                        target: trendDirection === 'ØµØ§Ø¹Ø¯' ? 
                            (currentPrice * (1 + trendStrength * 0.5)).toFixed(4) :
                            (currentPrice * (1 - trendStrength * 0.5)).toFixed(4),
                        totalCandles: totalCandles
                    });
                }
                
                // ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø­Ø³Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
                return patterns
                    .sort((a, b) => b.confidence - a.confidence)
                    .slice(0, 3); // Ø£Ù‚ÙˆÙ‰ 3 Ø£Ù†Ù…Ø§Ø·
                    
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø­Ù„Ù„ Ø§Ù„Ø£ØµÙ„ÙŠ:', error);
                
                // fallback Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¨Ø³Ø· ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£
                const prices = klineData.map(candle => parseFloat(candle[4]));
                const currentPrice = realCurrentPrice || prices[prices.length - 1];
                const totalCandles = klineData.length;
                const firstPrice = prices[0];
                const lastPrice = prices[prices.length - 1];
                const trendDirection = lastPrice > firstPrice ? 'ØµØ§Ø¹Ø¯' : 'Ù‡Ø§Ø¨Ø·';
                const trendStrength = Math.abs(lastPrice - firstPrice) / firstPrice;
                
                return [{
                    type: trendDirection === 'ØµØ§Ø¹Ø¯' ? 'Ù…ÙˆØ¬Ø© Ø¯Ø§ÙØ¹Ø©' : 'Ù…ÙˆØ¬Ø© ØªØµØ­ÙŠØ­ÙŠØ©',
                    direction: trendDirection,
                    confidence: Math.min(85, 60 + (trendStrength * 300)),
                    startIndex: 1,
                    endIndex: totalCandles - 1,
                    waveLength: trendStrength * 100,
                    target: trendDirection === 'ØµØ§Ø¹Ø¯' ? 
                        (currentPrice * (1 + trendStrength * 0.5)).toFixed(4) :
                        (currentPrice * (1 - trendStrength * 0.5)).toFixed(4),
                    totalCandles: totalCandles
                }];
            }
        }
        
        // Ø¯Ø§Ù„Ø© ØªØ±Ø¬Ù…Ø© Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
        function translatePatternType(englishType) {
            const translations = {
                'impulse': 'Ù…ÙˆØ¬Ø© Ø¯Ø§ÙØ¹Ø©',
                'correction': 'Ù…ÙˆØ¬Ø© ØªØµØ­ÙŠØ­ÙŠØ©', 
                'triangle': 'Ù…Ø«Ù„Ø« Ù…ØªÙ…Ø§Ø«Ù„',
                'wedge_up': 'Ø¥Ø³ÙÙŠÙ† ØµØ§Ø¹Ø¯',
                'wedge_down': 'Ø¥Ø³ÙÙŠÙ† Ù‡Ø§Ø¨Ø·',
                'diagonal': 'Ù‚Ø·Ø±',
                'zigzag': 'Ø²ÙŠØ¬Ø²Ø§Ø¬',
                'flat': 'Ù…Ø³Ø·Ø­',
                'complex': 'Ù…Ø¹Ù‚Ø¯'
            };
            
            if (!englishType) return 'Ù…ÙˆØ¬Ø© Ø¯Ø§ÙØ¹Ø©';
            
            const lowerType = englishType.toLowerCase();
            for (const [eng, ar] of Object.entries(translations)) {
                if (lowerType.includes(eng)) {
                    return ar;
                }
            }
            
            return englishType; // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø£ØµÙ„ÙŠ Ø¥Ø°Ø§ Ù„Ù… ÙŠØ¬Ø¯ ØªØ±Ø¬Ù…Ø©
        }

        // Ø¯Ø§Ù„Ø© Ù†Ø³Ø® Ø§Ù„ØªØ­Ù„ÙŠÙ„
        async function copyAnalysis() {
            try {
                const resultsDiv = document.getElementById('results');
                if (!resultsDiv || resultsDiv.style.display === 'none') {
                    showError('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù†Ø³Ø®Ù‡Ø§');
                    return;
                }
                
                // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„
                const symbol = document.querySelector('.symbol-info h2')?.textContent || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
                const price = document.querySelector('.symbol-info .price')?.textContent || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
                const summary = document.querySelector('.summary-box p')?.textContent || 'ØºÙŠØ± Ù…ØªÙˆÙØ±';
                const patterns = document.querySelectorAll('.pattern-card');
                
                let analysisText = `ğŸŒŠ ØªØ­Ù„ÙŠÙ„ Elliott Wave\n`;
                analysisText += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
                analysisText += `ğŸ“Š Ø§Ù„Ø±Ù…Ø²: ${symbol}\n`;
                analysisText += `ğŸ’° Ø§Ù„Ø³Ø¹Ø±: ${price}\n\n`;
                
                analysisText += `ğŸ“ Ù…Ù„Ø®Øµ Ø§Ù„ØªØ­Ù„ÙŠÙ„:\n${summary}\n\n`;
                
                if (patterns.length > 0) {
                    analysisText += `ğŸ“ˆ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ÙƒØªØ´ÙØ©:\n`;
                    patterns.forEach((pattern, index) => {
                        const type = pattern.querySelector('.pattern-type')?.textContent || '';
                        const confidence = pattern.querySelector('.confidence')?.textContent || '';
                        const direction = pattern.querySelector('.pattern-direction span:last-child')?.textContent || '';
                        const target = pattern.querySelector('.pattern-details p:last-child')?.textContent?.replace('ğŸ¯ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…ØªÙˆÙ‚Ø¹: ', '') || '';
                        
                        analysisText += `${index + 1}. ${type} ${direction} - Ø§Ù„Ø«Ù‚Ø©: ${confidence}\n`;
                        analysisText += `   ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: ${target}\n\n`;
                    });
                }
                
                analysisText += `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
                analysisText += `ğŸ•°ï¸ ÙˆÙ‚Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„: ${new Date().toLocaleString('ar-SA')}`;
                
                await navigator.clipboard.writeText(analysisText);
                showInfo('âœ… ØªÙ… Ù†Ø³Ø® Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­!');
                
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø³Ø®:', error);
                showError('ÙØ´Ù„ ÙÙŠ Ù†Ø³Ø® Ø§Ù„ØªØ­Ù„ÙŠÙ„. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…ØªØµÙØ­ ÙŠØ¯Ø¹Ù… Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù†Ø³Ø®.');
            }
        }
        
        // ØªØ´ØºÙŠÙ„ ØªØ­Ù„ÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
        window.addEventListener('load', () => {
            console.log('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ù…Ø­Ù„Ù„ Elliott Wave Ø¨Ù†Ø¬Ø§Ø­');
        });
    </script>
</body>
</html>

